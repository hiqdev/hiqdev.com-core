---
title: Альтернативная организация проекта на Yii2
---

# Альтернативная организация проекта на Yii2

Как предлагается создавать проект на Yii2 сейчас? Выбираете шаблон проекта: basic или
advanced, форкаете себе, потом пишете и комитите туда. Бам! Случилась копипаста, ваш
проект и шаблон теперь развиваются отдельно. Вам не получить исправлений, внесенных, в
шаблон, а в `yii2-app-basic`, естественно, не возьмут доработок специфических для вашей
задачи. Это проблема номер один.

Как расширяется проект на Yii2? Выбираете подходящие расширения и подключаете их с
помощью композера. Находите пример конфига этого расширения в README и копипастите в
конфиг своего приложения. Оопс... Опять копипаста. Вылазящяя разными боками, в том
числе таким: в большом проекте используется много расширений - конфиг приложения
становится огромным и просто нечитаемым. Это проблема номер два.

Как эти проблемы связаны? Первая решается так: выделяем переиспользуемый код и
превращаем в расширение. И снова здравствуйте: у расширения есть свой конфиг -
получили вторую проблему.

Наиболее остро эти проблемы стоят для повторно используемых решений,
когда надо поднимать много/несколько, в принципе одинаковых проектов,
но с большими/маленькими изменениями.
Плюс избавление от копипасты и переиспользование кода ещё никому не мешало.

Хочу поделиться своим вариантом решения этих проблем.

## Система плагинов

Не буду томить душу, изложу суть сразу, чтоб, если-что, было удобненько расплеваться
сразу, не дочитывая до конца.

Итак, решение такое: использовать систему плагинов - с самого начала создавать
свой проект как плагин (расширение вместе с конфигом), делить проект на плагины и
собирать конфиг приложения автоматически из конфигов плагинов.

Тут я должен приостановиться и объяснить что я называю плагином.
В yii2 предусмотрены расширения (yii2 extension) и они дают возможность
организовывать переиспользуемый код и подключать его к проекту композером.
Но мало-мальски сложное расширение нуждается в конфигурации.
И тут фреймворк не помогает.
У создателя расширения есть два варианта:

- описать желаемый конфиг в README и предложить програмеру его скопипастить
- сделать [bootstrap](http://www.yiiframework.com/doc-2.0/guide-structure-extensions.html#bootstrapping-classes) в своём расширении, который будет закидывать желаемый конфиг
  в конфиг приложения.

Первый вариант я уже покритиковал в самом начале, возьмусь за второй:

- bootstrap запускается довольно рано, но всё таки объект `Application` уже создан и
  что-то уже просто не получится сконфигурировать
- довольно сложно правильно смержиться с конфигом уже созданного приложения,
  придётся работать не с целым массивом конфига, а по частям: компоненты отдельно,
  алиасы отдельно, контейнер отдельно, ... (я пробовал &mdash; так счастья не видать)
- bootstrap не ленивый, он запускается на каждый запрос к приложению и если
  таких bootstrap'ов много &mdash; они просто будут бить по производительности

В общем, пройдя несколько итераций, намучавшись с разными вариантами родилось
радикальное решение - собирать конфиг за пределами приложения и ещё до его запуска
(хм, звучит просто и очевидно, но, как известно, хорошая мысля приходит опосля).
Собирать оказалось удобнее всего плагином к композеру, из него есть удобный доступ
ко всей иерархии зависимостей проекта. Так получился
[composer-config-plugin](https://github.com/hiqdev/composer-config-plugin).

## Composer Config Plugin

Composer-config-plugin работает довольно просто:

- обходит все зависимости проекта, находит в них описание конфигов плагинов
  в `extra` секции их `composer.json`
- мержит конфиги в соответствии с описанием и иерархией пакетов и записывает
  результирующие конфиг файлы

В `composer.json` расширения (которое превращается в плагин)
добавляются такие строчки:

```json
    "extra": {
        "config-plugin": {
            "hisite": "src/config/hisite.php"
        }
    }
```

Это значит замержить в конфиг под названием `hisite` содержимое файла
`src/config/hisite.php`. А в файле этом будет просто то, что плагин хочет добавить
в конфиг приложения, например, конфиг интернационализации:

```php
<?php

return [
    'components' => [
        'i18n' => [
            'translations' => [
                'my-category' => [
                    'class' => \yii\i18n\PhpMessageSource::class,
                    'basePath' => '@myvendor/myplugin/messages',
                ],
            ],
        ],
    ],
];
```

Конфигов может быть сколько угодно, включая специальные: `dotenv`, `defines`
и `params`, которые обрабатываются, в принципе, также как и другие конфиги,
только в правильном порядке:

- переменные окружения &mdash; `dotenv`
- константы &mdash; `defines`
- параметры &mdash; `params`
- конфиги &mdash; `name1`, `name2`, ...

Таким образом, чтобы значения полученные на предыдущих шагах могли быть использованы
на всех ппоследующих.

То есть:  переменные окружения могут использоваться для назначения констант.
Константы и переменные окружения могут использоваться для назначения параметров.
И весь набор: параметры, константы и переменные окружения могут использоваться
в конфигах.

В общем-то всё! `composer-config-plugin` просто мержит все массивы конфигов аналогом
функции `yii\base\helpers\ArrayHelper::merge`.
Естественно, конфиги мержатся в правильном порядке &mdash;
с учётом кто кого реквайрит &mdash;
таким образом, чтобы конфиг каждого пакета мержился
после своих зависимостей и мог перезаписать значения заданные ими.
Т.е. самый верхний пакет имеет полный контроль над конфигом и управляет всеми
значениями, а плагины только задают дефолтные значения.
В общем, процесс повторяет сборку конфигов в `yii2-app-advanced`, только более
масштабно.

Изпользовать в приложении тривиально &mdash; добавляем в `web/index.php`:

```php
$config = require hiqdev\composer\config\Builder::path('hisite');

(new yii\web\Application($config))->run();
```

Найти больше информации и примеров, а также задать вопросы можно на гитхабе:
[hiqdev/composer-config-plugin](https://github.com/hiqdev/composer-config-plugin).

Очень простой пример плагина
[hiqdev/yii2-yandex-plugin](https://github.com/hiqdev/yii2-yandex-plugin).
Но он наглядно демонстрирует возможности этого подхода. Чтобы получить счётчик
Яндекс.Метрики достаточно зареквайрить плагин и задать параметр `yandexMetrika.id`.
Всё! Не надо ничего копипастить в свой конфиг, не надо добавлять виджет в layout -
не надо касаться рабочего кода.
Плагин &mdash; это цельный кусок функционала, который позволяет расширять систему
не внося изменений в существующий код.

<img style="float:right" src="http://cs5.pikabu.ru/images/big_size_comm/2015-03_6/1427402470529.jpg"/>

&mdash; Что? Можно написать новую фичу, не поломав старые?!<br>
&mdash; Да.<br>
&mdash; Крутяк! Теперь можно не писать тесты?<br>
&mdash; Нет... Так не бывает...<br>

Итого, `composer-config-plugin` даёт систему плагинов и решает вопрос повторного
использования так сказать "малых архитектурных форм". Пора вернуться к главному -
организации больших переиспользуемых проектов. Повторю и уточню предлагаемое решение:
создавать проект как систему плагинов, организованную в правильную иерархию.

## Иерархия пакетов

Самый простой вариант организации проекта такой &mdash; наш проект реквайрит композером
фреймворк и *сторонние* расширения (*"сторонними"* я называю не являющиеся частью
нашего проекта), т.е. получается такая простая иерархия пакетов (репозиториев):

- проект (выросший из шаблона приложения)
    - расширения
    - фреймворк

Пропускаю все промежуточные варианты организации проверенные и отброшенные по итогам
практической эксплуатации. И перехожу сразу к оптимальной иерархии, которой мы
придерживаемся сейчас:

- *"корень"*
    - плагины специфичные для данного варианта проекта
    - основной проект
        - плагины проекта
        - *сторонние* плагины
        - базовый проект
            - плагины нужные для работы базового проекта
            - фреймворк

Иерархия отображает кто кого реквайрит, т.е. корень реквайрит основной проект,
тот в свою очередь &mdash; базовый проект, а базовый проект &mdash; фреймворк.

&mdash; Воу-воу! Полегче! Что за "корень" и "базовый проект"?

Извиняюсь, всё придумал сам, терминологии подходящей не нашёл, пришлось велосипедить,
буду признателен за лучшие варианты.

*"Корнем"* я называю самый внешний пакет,
содержащий код, конфиг и другие файлы специфические для данного конкретного варианта
реализации вашего проекта, то, чем этот вариант отличается от основного проекта.
В идеале содержит буквально несколько файлов, об этом ниже.

*"Базовый проект"* это то, во что превращается `yii2-app-basic` в этой схеме.
Т.е. переиспользуемая основа приложения реализующая некоторый базовый
функционал и оформленная в виде плагина.
Эта запчасть не обязательна, но очень полезна. Вам не надо её делать самому, она
может разрабатываться сообществом как сейчас разрабатывается `yii2-app-basic`.
Мы разрабатываем HiSite, об этом ниже.

Таким образом пакеты образуют иерархию композиции -
более внешний пакет использует внутренний, в основном переиспользуя его поведение,
но переопределяя свою специфику:
*"корень"* использует и уточняет основной проект,
основной проект &mdash; базовый, базовый проект &mdash; фреймворк.

Необходимо уточнить, что речь идёт только об организации кода, т.е. про разделение
кода по пакетам/плагинам.
Архитектурное деление проекта на слои, естественно, независимо от
деления на пакеты, но они могут дополнять друг друга. Например, доменная логика может
быть вынесена в отдельный пакет для переиспользования между разными проектами.

&mdash; Аааа! Нужен пример!

Например, Вы делаете на потоке сайты визитки. Базовый функционал везде одинаковый,
но есть фичи за дополнительну плату, например каталог и, естественно, сайты отличаются
внешним видом (темой) и кучей параметров.
Это можно организовать в такую иерархию пакетов:

- `business-card-no42.com` - *"корень"*
    - `myvendor/yii2-theme-cool` - плагин специфичный для данного сайта
    - `myvendor/business-card-catalog` - плагин проекта подключенный на данном сайте
    - `myvendor/business-card` - основной проект
        - `myvendor/business-card-contacts` - плагин проекта используемый на всех сайтах
        - `othervendor/yii2-cool-stuff` - *сторонний* плагин
        - `hiqdev/hisite` - базовый проект
            - `yiisoft/yii2-swiftmail` - плагин нужный для работы базового проекта
            - `yiisoft/yii2` - фреймворк

Надеюсь не открыл Америки, и все более менее так и делят свои проекты на части.
Только, наверно, без *"корня"*. Попытаюсь донести его полезность.

## *"Корень"*

В *"корне"* достаточно всего пару файлов, которые подлежат копированию из шаблона
и настройке под данную инсталяцию проекта. Можно и желательно, обойтись
всего тремя файлами:

- `.env` - переменные окружения, например,`ENV=prod`
- `composer.json` - тут подключается основной проект и специфичные для него плагины
- `src/config/params.php` - явки, пароли, параметры проекта и используемых плагинов

Пароли, можно положить в `.env` и потом использовать их в `params.php` так:

```php
return [
    'db.password' => $_ENV['DB_PASSWORD'],
];
```

Учитывая "легкоусвояемость" `.env` лучшими претендентами на вынос в `.env` являются
параметры используемые другими (не PHP) технологиями.

Конечно, можно и нужно ложить в "корень" некоторый конфиг и даже код специфичный
сугубо для данной инсталяции, не подлежащий копипастингу.
Как только вижу копипасту, страшно её не люблю &mdash; уношу в какой-нибудь плагин.

Остальные файлы и каталоги необходимые для функционирования приложения
(`web/assets/`, `web/index.php`) стандартны,
их нужно создавать и назначать права "сборщиком" (build tool, task runner)
мы велосипедим свой, но это уже совсем другая история.

По сути, "корень" &mdash; это `params-local.php` на стероидах.
В нём концентрируется отличие конкретной инсталяции проекта от общего
переиспользуемого кода. Мы создаём репозиторий под корень и храним его на нашем
приватном git-сервере, поэтому комитим туда даже секреты (но это холиварная тема).
Все остальные пакеты &mdash; в публичном доступе на GitHub'е.
Мы комитим `composer.lock` в корне, поэтому перенос проекта на другой сервер
делается просто `composer create-project` (я знаю &mdash; Docker
получше будет, но об этом в следующий раз).

-- А можно ещё конкретнее? Покажите мне код наконец!

## HiSite и Asset Packagist

Одно из *"базовых приложений"*, которые мы развиваем - **HiSite**
[hiqdev/hisite](https://github.com/hiqdev/hisite) - это основа для типичного
сайта, как `yii2-app-basic,` только сделанная как плагин, что даёт все
преимущества переиспользования кода над копипастингом:

- Вы можете основать свой проект на HiSite'е и получать его обновления
- Вы можете со временем заменить базовый проект на другой, совместимый,
  но, например, с большим функционалом.

Шаблон *"корня"* для проекта на HiSite'е здесь -
[hiqdev/hisite-template](https://github.com/hiqdev/hisite-template).
Подробнее в README.

Ещё один реальный рабочий проект, подходящий в качестве примера,
сделанный, используя этот подход и полностью доступный на GitHub'е &mdash;
[Asset Packagist](https://asset-packagist.org) &mdash;
packagist-совместимый репозиторий, который позволяет устанавливать Bower и NPM
пакеты как нативные composer пакеты.

Иерархия зависимостей выглядит так:

- *"корень"* &mdash; [hiqdev/asset-packagist.org]
    - плагин темы &mdash; [hiqdev/yii2-theme-original]
    - проект &mdash; [hiqdev/asset-packagist]
        - базовый проект &mdash; [hiqdev/hisite]
            - фреймворк &mdash; [yiisoft/yii2]

[hiqdev/asset-packagist.org]:   https://github.com/hiqdev/asset-packagist.org
[hiqdev/yii2-theme-original]:   https://github.com/hiqdev/yii2-theme-original
[hiqdev/asset-packagist]:       https://github.com/hiqdev/asset-packagist
[hiqdev/hisite]:                https://github.com/hiqdev/hisite
[yiisoft/yii2]:                 https://github.com/yiisoft/yii2

В [README](https://github.com/hiqdev/asset-packagist.org) корня
описано как поднять проект у себя &mdash; в общем-то `composer create-project` и всё.
В `composer.json` корня можно поменять `yii2-theme-original` на `yii2-theme-flat`
запустить `composer update` и сайт переоденется в новую тему. Вот так просто.
Сила плагинов и правильной организации.

## Итоги подведём

Тема обширная, множество подробностей пришлось опустить.
Надеюсь получилось донести общую идею. Ещё раз, используя введенную терминологию:

- переиспользуем код в виде плагинов, т.е. код вместе с конфигурацией
- создаём проект как иерархию плагинов
- отделяем переиспользуемую часть проекта от конкретной инсталяции с помощью "корня"

Мы используем описанный подход около года, впечатления самые положительные &mdash;
волосы стали мягкие и шелковистые: разделяем и властвуем,
клепаем плагины легко и непринуждённо, [100+] и останавливаться не собираемся,
нужен новый функционал - делаем новый плагин.

[100+]: https://hiqdev.com/packages

Подход, в той или иной мере применим для других фреймворков и даже языков...
Ой, Остапа понесло... На сегодня хватит!
Спасибо за внимание.  Продолжение следует.

## P.S.

На написание таких объёмов текста сподвигла
[серия](http://fabien.potencier.org/symfony4-compose-applications.html)
[статей](http://fabien.potencier.org/symfony4-monolith-vs-micro.html)
[Фабьена Потенсьера](http://fabien.potencier.org/)
(автора Symfony) про грядущий Symfony 4.
Стыдно сказать, не всё понял (там пока только тизеры &mdash; кода нет), но уловил,
что система бандлов будет доработана в сторону их автоматической конфигурации,
для получения "нового способа создавать и развивать ваши приложения с лёгкостью"
(new way to create and evolve your applications with ease).

Я люблю Yii. Давайте сделаем в Yii лучше!
