---
title: Альтернативная организация проекта на Yii2
---

# Альтернативная организация проекта на Yii2

Как предлагается создавать проект на Yii2 сейчас? Выбираете шаблон проекта basic или
advanced, форкаете себе, потом пишете и комитите туда. Бам! Случилась копипаста, ваш
проект и шаблон теперь развиваются отдельно. Вам не получить исправлений внесенных в
шаблон, а в yii2-app-basic естественно не возьмут доработок специфических для вашей
задачи. Это проблема номер один.

Как расширяется проект на Yii2? Выбираете подходящие расширения и подключаете их с
помощью композера. Смотрите пример конфига этого расширения в README и копипастите в
конфиг своего приложения. Оопс... Опять копипаста. Вылазящяя разными боками, в том
числе таким: в большом проекте используется много расширений и конфиг приложения
становится огромным и просто нечитаемым. Это проблема номер два.

Как эти проблемы связаны? Первая решается так: выделяем переиспользуемый код и
превращаем в расширение. И снова здравствуйте: у расширения есть свой конфиг -
получили вторую проблему.

Наиболее остро эти проблемы стоят для повторно используемых решений когда
надо поднимать много в принципе одинаковых проектов с маленькими/большими
изменениями.
Но избавление от копипасты и переиспользование кода ещё никому не мешало.

Хочу поделиться своим вариантом решения этих проблем.

## Система плагинов

Не буду томить душу, изложу суть сразу, чтоб если-что было удобненько расплеваться
сразу не дочитывая до конца.

Итак, решение такое: использовать систему плагинов - с самого начала создавать
свой проект как плагин (расширение вместе с конфигом), делить проект на плагины и
собирать конфиг приложения автоматически из конфигов плагинов.

Тут я должен приостановиться и объяснить что я называю плагином.
В yii2 предусмотрены расширения (yii2 extension) и в принципе они дают возможность
организовывать переиспользуемый код и подключать его к проекту композером.
Но мало мальски сложное расширение нуждается в конфигурации. И тут фреймворк
не помогает.
У создателя расширения есть два варианта:

- описать желаемый конфиг в README и предложить програмеру его скопипастить
- сделать bootstrap в своём расширении, который будет закидывать желаемый конфиг
  в конфиг приложения.

Первый вариант я уже покритиковал в самом начале, возьмусь за второй:

- bootstrap запускается очень рано, но всё таки объект Application уже создан и
  что-то уже просто не получится сконфигурить
- довольно сложно правильно смержиться с конфигом уже созданного приложения,
  прийдётся работать не с целым массивом конфига, а по частям: компоненты отдельно,
  алиасы отдельно, контейнер отдельно, ... (я пробовал - не понравилось)
- bootstrap не ленивый, он запускается на каждый запрос к приложению и если
  таких bootstrap'ов много они просто будут бить по производительности

В общем, пройдя несколько итераций, намучавшись с разными вариантами родилось
радикальное решение - собирать конфиг ещё до старта приложения (хм, звучит просто
и очевидно, но хорошая мысля приходит опосля).
Собирать оказалось удобнее всего плагином к композеру, из него есть удобный доступ
ко всей иерархии зависимостей проекта. Так получился composer-config-plugin.

## Composer Config Plugin

Composer-config-plugin работает довольно просто:

- обходит все зависимости проекта, находит в них описание конфигов плагинов
  в `extra` секции их `composer.json`
- мержит конфиги в соответствии с описанием и иерархией пакетов и записывает
  результирующие конфиг файлы

В `composer.json` расширения (которое превращается в плагин)
добавляются такие строчки:

```json
    "extra": {
        "config-plugin": {
            "hisite": "src/config/hisite.php"
        }
    }
```

Это значит закинуть в конфиг под названием `hisite` содержимое файла
`src/config/hisite.php`. А в файле этом будет просто то, что плагин хочет закинуть
в конфиг приложения, например, конфиг интернационализации:

```php
<?php

return [
    'components' => [
        'i18n' => [
            'translations' => [
                'my-category' => [
                    'class' => \yii\i18n\PhpMessageSource::class,
                    'basePath' => '@myvendor/myplugin/messages',
                ],
            ],
        ],
    ],
];
```

В общем то всё, `composer-config-plugin` просто мержит все массивы конфигов аналогом
функции `base\helpers\ArrayHelper::merge`.
Естественно конфиги мержатся в правильном порядке, с учётом кто кого реквайрит,
таким образом, чтобы конфиг каждого пакета мержился
после своих зависимостей и мог перезаписать значения заданные ими.
Т.е. самый верхний пакет имеет полный контроль над конфигом и управляет всеми
значениями, а плагины только задают дефолтные значения.

Найти больше информации и примеров, а также задать вопросы можно на гитхабе:
https://github.com/hiqdev/composer-config-plugin.

`Composer-config-plugin` даёт систему плагинов и решает вопрос повторного
использования так сказать "малых архитектурных форм". Перейдём к главному -
организации больших переиспользуемых проектов. Повторюсь, предлагаемое решение:
создавать проект как систему плагинов, организованную в правильную иерархию.

## Иерархия пакетов

Самый простой вариант организации проекта такой: наш проект реквайрит композером
фреймворк и *сторонние* расширения (*"сторонними"* я называю не являющиеся частью
нашего проекта), т.е. получается такая простая иерархия пакетов (репозиториев):

- проект (выросший из шаблона приложения)
    - расширения
    - фреймворк

Пропускаю все промежуточные варианты проверенные и отброшенные по итогам практической
эксплуатации. И перехожу сразу к оптимальной иерархии, которой я придерживаюсь сейчас:

- *"корень"*
    - плагины специфичные для данного варианта проекта
    - проект
        - плагины проекта
        - *сторонние* плагины
        - базовый проект
            - плагины нужные для работы базового проекта
            - фреймворк

-- Воу-воу! Полегче! Что за "корень" и "базовый проект"?

Извиняюсь, всё придумал сам, терминологии подходящей не нашёл, пришлось велосипедить, буду признателен за лучшие варианты.

*"Корнем"* я называю самый внешний пакет, ему достаточно содержать только
`composer.json` и конфиг специфический для данного конкретного варианта реализации
вашего проекта.
*"Корень"* является шаблоном и это единственный код подлежащий копипастингу с
последующим тюнингом, но копипасты минимум - весь дефолтный конфиг должен быть
в проекте и плагинах.

*"Базовый проект"* это то, во что превращается `yii2-app-basic` в этой схеме.
Т.е. переиспользуемая основа приложения реализующая некий базовый
функционал и оформленная в виде плагина.
Эта запчасть не обязательна, но очень полезна. Вам не надо её делать самому, она
может разрабатываться сообществом как сейчас разрабатывается `yii2-app-basic`.

-- Аааа! Нужен пример!

Например вы делаете на потоке сайты визитки. Базовый функционал везде одинаковый
но есть фичи за дополнительну плату, например каталог и естественно сайты отличаются
внешним видом (темой) и кучей параметров.
Это можно организовать в такую иерархию пакетов:

- *"корень"*: mylab/my-new-site.com
    - mylab/yii2-theme-cool - плагин специфичный для данного сайта
    - mylab/business-card - основной проект
        - mylab/business-card-catalog - плагин проекта
        - yiisoft/yii2-debug - *сторонний* плагин
        - hiqdev/hisite - базовый проект
            - hiqdev/yii2-thememanager - плагин нужный для работы базового проекта
            - yiisoft/yii2 - фреймворк

## HiSite

Одно из *"базовых приложений"* которые мы развиваем - **HiSite**.
https://github.com/hiqdev/hisite

Шаблон *"корня"* здесь -
https://github.com/hiqdev/hisite-template

Структура каталогов "корня", только существенные файлы:

- composer.json
- src/
    - config/
        - defines.php
        - params.php
- web/
    - index.php
- vendor/

Структура каталогов проекта:

- asset-packagist/
    - src/
        - config/
            - params.php
            - hisite.php
        - controllers
        - views

## Итоги подведём

Тема обширная, множество подробностей пришлось опустить, надеюсь получилось
донести общую идею.
Мы используем описанный подход около года, впечатления самые положительные -
волосы стали мягкие и шелковистые: клепаем плагины как пирожки.

Подход, в той или иной мере применим для других фреймворков и даже языков...
Ой, Остапа понесло... На сегодня хватит! Засим откланиваюсь. Спасибо за внимание.
Продолжение следует.

